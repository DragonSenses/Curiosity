package Java.Math;

import java.util.Random;    // old way to generate random numbers
import java.util.concurrent.ThreadLocalRandom;  // Finer way to generate random numbers

/**
 * Task: Generate random integers between zero and some upper bound, n [0,n)
 * 
 * Demonstrates a few flaws about java.util.Random pseudorandom number generator
 * and a better library that produces finer random numbers with more speed.
 * 
 * Randoms poor performance stems from the fact that it falters in multi-threaded
 * environments. Its poor performance is due to contention - given that multiple
 * threads share the same Random instance. 
 * 
 * ThreadLocalRandom combines ThreadLocal and Random classes and is isolated to the
 * current thread. Achieves better performance in multithreaded environments by
 * avoiding any concurrent access to instances of Random. Random number optained
 * by one thread is not affected by the other thread, whereas java.util.Random 
 * provides random numbers globally.
 */
public class MakeRandomNumbers {
    
    // Standard, Common, but deeply flawed
    static Random rnd = new Random();

    /**
     * 3 Flaws. 1) if n is small power of two, sequence of random numbers will
     * repeat itself after a short period (pseudorandom number generator is 
     * periodic). 2) if n is not a power of two, some numbers will on average
     * be returned more frequently than others; the effect is more pronounced
     * when n is large. 3) on rare occasions, can fail catastrophically, 
     * returning a number outside the specified range. Because the method 
     * attempts to map the value returned by rnd.nextInt() to a non-negative int
     * by calling Math.abs. If nextInt() returns Integer.MIN_VALUE, Math.abs 
     * will also return Integer.MIN_VALUE, and remainder operator (%) will 
     * return a negative number, assuming n is not a power of two. 
     * @param n the exclusive upper bound to produce random number from 
     * @return a random number between the range of 0 and n
     */
    static int badRandom(int n) {
        return Math.abs(rnd.nextInt()) % n ;
    }

    /**
     * To demonstrate flaw #2, this method generates a million random numbers in
     * a carefully chosen range and then prints out how many of the numbers fell
     * in the lower half of the range. If worked properly, should print a number 
     * close to half a million;
     * 
     * Expected: Half a Million
     * Actual: 666,667 
     * 
     * Two-thirds of the numbers generated by random method fall in the lower 
     * half of its range!
     */
    static void displayBadRandom() {
        int n = 2*(Integer.MAX_VALUE/3); //715827882
        int lo = 0;
        for(int i = 0; i < 1000000; i++){ // Loop a Million Times
            if(badRandom(n) < n/2) {
                lo++;
            }
        }
        System.out.println(lo);
    }

    static ThreadLocalRandom random = new ThreadLocalRandom();

    static int goodRandom(int n){
        return Math.abs()
    }

    public static void main(String[] args){
        displayBadRandom();
    }
}
