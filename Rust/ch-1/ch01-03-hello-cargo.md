## Hello, Cargo!

Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call the libraries that your code needs
*dependencies*.)

The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. If we had built the “Hello, world!” project with Cargo, it would
only use the part of Cargo that handles building your code. As you write more
complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.

Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the installation section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following in your terminal:

```console
$ cargo --version
```

If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.

### Creating a Project with Cargo

Let’s create a new project using Cargo and look at how it differs from our
original “Hello, world!” project. Navigate back to your *projects* directory
(or wherever you decided to store your code). Then, on any operating system,
run the following:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

The first command creates a new directory and project called *hello_cargo*.
We’ve named our project *hello_cargo*, and Cargo creates its files in a
directory of the same name.

Go into the *hello_cargo* directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside.

It has also initialized a new Git repository along with a *.gitignore* file.
Git files won’t be generated if you run `cargo new` within an existing Git
repository; you can override this behavior by using `cargo new --vcs=git`.

> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.

Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.

#### Filename: Cargo.toml

<Listing number="1-2" file-name="Cargo.toml" caption="Contents of *Cargo.toml* generated by `cargo new`">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

</Listing>

This file is in the **TOML** (*Tom’s Obvious, Minimal
Language*) format, which is Cargo’s configuration format.

Let's break down the contents of the `Cargo.toml` file:

1. `[package]`: This section heading indicates that the following statements configure a package. As you add more information to this file, you can include other sections.

2. `name`, `version`, and `edition`: These three lines set the configuration information that Cargo needs to compile your program:
   - `name`: Specifies the name of your package.
   - `version`: Specifies the version of your package.
   - `edition`: Specifies the edition of Rust to use (in this case, the 2021 edition).

3. `[dependencies]`: This line starts a section where you can list any dependencies (also known as *crates*) for your project. While you won't need other crates for this specific project, you'll likely use this dependencies section in your first project in Chapter 2.

#### Filename: src/main.rs

Now open src/main.rs and take a look:

```rust
fn main() {
    println!("Hello, world!");
}
```

1. **Generated "Hello, World!" Program:**
   - Cargo has generated a "Hello, world!" program for you, similar to the one we wrote in Listing 1-1.
   - The code is placed in the `src` directory.
   - You'll find a `Cargo.toml` configuration file in the top-level directory.

2. **Project Organization with Cargo:**
   - Cargo expects your source files to reside inside the `src` directory.
   - The top-level project directory is reserved for README files, license information, configuration files, and other non-code-related content.
   - Using Cargo helps you maintain a well-organized project structure.

3. **Converting Non-Cargo Projects:**
   - If you initially created a project without using Cargo (like the "Hello, world!" project), you can convert it to use Cargo.
   - Move your project code into the `src` directory.
   - Create an appropriate `Cargo.toml` file.

### Building and Running a Cargo Project

1. **Building and Running with Cargo:**
   - To build your project using Cargo, run `cargo build` from your `hello_cargo` directory.
   - The resulting executable file is located in `target/debug/hello_cargo` (or `target\debug\hello_cargo.exe` on Windows).
   - By default, Cargo creates a debug build and places the binary in a `debug` directory.
   - You can run the executable using `./target/debug/hello_cargo` (or `.\\target\\debug\\hello_cargo.exe` on Windows).

2. **Cargo.lock File:**
   - When you run `cargo build` for the first time, Cargo creates a `Cargo.lock` file at the top level.
   - The `Cargo.lock` file keeps track of exact dependency versions.
   - It's automatically managed by Cargo, and you won't need to modify it manually.

3. **Using `cargo run`:**
   - Instead of separately building and running, you can use `cargo run` to compile and execute the binary in one command.
   - It's more convenient than specifying the whole path to the binary.

4. **`cargo check`:**
   - Use `cargo check` to quickly verify that your code compiles without producing an executable.
   - It's faster than `cargo build` and useful for continuous code checking during development.

Now let’s look at what’s different when we build and run the “Hello, world!”
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. Because the default build is a debug build, Cargo puts the binary in
a directory named *debug*. You can run the executable with this command:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.

We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resultant executable all in one command:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Using `cargo run` is more convenient than having to remember to run `cargo build` and then use the whole path to the binary, so most developers use `cargo
run`.

Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it didn’t
rebuild but just ran the binary. If you had modified your source code, Cargo
would have rebuilt the project before running it, and you would have seen this
output:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build` because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process of letting you know if your project is still compiling! As
such, many Rustaceans run `cargo check` periodically as they write their
program to make sure it compiles. Then they run `cargo build` when they’re
ready to use the executable.

#### Cargo Summary

Let’s recap what we’ve learned so far about Cargo:

* We can create a project using `cargo new`.
* We can build a project using `cargo build`.
* We can build and run a project in one step using `cargo run`.
* We can build a project without producing a binary to check for errors using
  `cargo check`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.

An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.